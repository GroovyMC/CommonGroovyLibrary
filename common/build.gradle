plugins {
    id 'convention.shared'
    alias libs.plugins.architectury.loom
    alias libs.plugins.mdg
}

modsDotGroovy.multiplatform.expose()

configurations {
    for (def sourceSet in ['main', 'extension', 'transform']) {
        for (def type in ['Java', 'Groovy', 'Resources']) {
            create("${sourceSet}Common${type}") {
                canBeResolved = false
                canBeConsumed = true
            }
        }
    }
    exportedClasses {
        canBeResolved = false
        canBeConsumed = true
    }
}

loom {
    runConfigs.configureEach {
        ideConfigGenerated = false
    }
}

registrationUtils {
    projects {
        common {
            type 'common'
        }
    }
}

import net.fabricmc.loom.task.AbstractRemapJarTask
tasks.withType(AbstractRemapJarTask).each {
    it.targetNamespace = "named"
}

dependencies {
    mappings loom.layered() {
        officialMojangMappings()
        parchment("org.parchmentmc.data:parchment-${libs.versions.parchment.minecraft.get()}:${libs.versions.parchment.mappings.get()}@zip")
    }
    minecraft libs.minecraft
    modImplementation libs.fabric.loader

    sharedCompileOnly libs.groovybundler
    sharedCompileOnly libs.jankson
    sharedCompileOnly libs.nightconfig.toml
}

afterEvaluate {
    configurations.transformCompileClasspath.extendsFrom configurations.minecraftNamedCompile
    configurations.extensionCompileClasspath.extendsFrom configurations.minecraftNamedCompile

    dependencies {
        transformCompileOnly reg.common()
        extensionCompileOnly reg.common()
    }
}

artifacts {
    for (def sourceSet in ['main', 'extension', 'transform']) {
        add("${sourceSet}CommonJava", sourceSets.named(sourceSet).get().java.sourceDirectories.singleFile)
        add("${sourceSet}CommonGroovy", sourceSets.named(sourceSet).get().groovy.sourceDirectories.singleFile)
        add("${sourceSet}CommonResources", sourceSets.named(sourceSet).get().resources.sourceDirectories.singleFile)
        def outputClasses = project.objects.directoryProperty()
        sourceSets.named(sourceSet).get().output.classesDirs.files.each {
            add('exportedClasses', it) {
                builtBy tasks.named(sourceSets.named(sourceSet).get().classesTaskName)
            }
        }
    }
}
